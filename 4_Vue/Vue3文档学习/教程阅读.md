# 教程阅读



## 1、基础

- ##### v-bind绑定的值如果是空字符串，那么该属性也会被包含在元素中

- ##### 动态绑定参数：

  ```js
  <a v-bind:[attributeName]="url"> ... </a>
  <a v-on:[eventName]="doSomething"> ... </a>
  ```

- ##### 对动态参数值约定：

  ```js
  // 动态参数预期会求出一个字符串，`null` 例外。这个特殊的 `null` 值可以用于显式地移除绑定。任何其它非字符串类型的值都将会触发一个警告。
  ```

- ##### 对动态参数表达式约定：https://v3.cn.vuejs.org/guide/template-syntax.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9



- ##### 防抖和节流：vue中没有内置支持防抖和节流，可以通过lodash等库来实现



- ##### 移出组件时取消定时器：

  ```JS
    unmounted() {
      // 移除组件时，取消定时器
      this.debouncedClick.cancel()
    },
  ```

- ##### 计算属性的setter：

- ##### 侦听器：需要在数据改变时执行异步或者开销大的操作时使用



- ##### class和style绑定：对象语法与数组语法：https://v3.cn.vuejs.org/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95

- ##### 在组件上使用class：如果组件有对个根元素

  ```js
  // 可以使用 $attrs 属性指定要绑定到那个根元素上
  <div id="app">
    <my-component class="baz"></my-component>
  </div>
  const app = Vue.createApp({})
  
  app.component('my-component', {
    template: `
      <p :class="$attrs.class">Hi!</p>
      <span>This is a child component</span>
    `
  })
  ```

  

- ##### 绑定内联样式：对象语法、数组语法



- ##### v-for遍历对象：可以有三个参数 value、key、index



- ##### 数组更新检测：push()、pop()、shift()、unshift()、splice()、sort()、reverse()

- ##### 替换数组：filter()、concat()、slice()不会改变原数组，而是返回一个新的数组



- ##### 事件修饰符：.stop、.prevent、capture、.self、once、passive

  ```js
  <!-- 阻止单击事件继续冒泡 -->
  <a @click.stop="doThis"></a>
  
  <!-- 提交事件不再重载页面 -->
  <form @submit.prevent="onSubmit"></form>
  
  <!-- 修饰符可以串联 -->
  <a @click.stop.prevent="doThat"></a>
  
  <!-- 只有修饰符 -->
  <form @submit.prevent></form>
  
  <!-- 添加事件监听器时使用事件捕获模式 -->
  <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
  <div @click.capture="doThis">...</div>
  
  <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
  <!-- 即事件不是从内部元素触发的 -->
  <div @click.self="doThat">...</div>
  
  <!-- 点击事件将只会触发一次 -->
  <a @click.once="doThis"></a>
  
  <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发，   -->
  <!-- 而不会等待 `onScroll` 完成，                    -->
  <!-- 以防止其中包含 `event.preventDefault()` 的情况  -->
  <div @scroll.passive="onScroll">...</div>
  
  不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。
  ```

- ##### 按键修饰符：.enter、.tab、.delete、.esc、.space、.up、.down、.left、.right

  ```js
  <!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
  <input @keyup.enter="submit" />
  你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。
  ```

- ##### 系统修饰键：.ctrl、.alt、shift、meta

- ##### .exact修饰符：修饰符允许你控制由精准的系统修饰符组合触发的事件

- ##### 鼠标修饰符：.left、.right、.middle

- ##### v-model绑定和抛出事件：

- ##### 表单输入修饰符：.lazy、.number、.trim



- ##### 在组件上使用v-model：

  ```html
  <input v-model="searchText" />
  等价于：
  <input :value="searchText" @input="searchText = $event.target.value" />
  当用在组件上时则这样：
  <custom-input
    :model-value="searchText"
    @update:model-value="searchText = $event"
  ></custom-input>
  ```

- ##### 解析DOM模板时的注意事项：元素位置受限、大小写不敏感、



## 2、深入组件

- ##### 组件注册之组件名：

  ```js
  // 1、如果直接在DOM中使用一个组件时
  强烈建议遵循w3c规范：全部小写、多个单词用连字符连接
  // 2、在字符串模板或者单文件组件定义组件时：
  使用kebab-case、PascalCase
  ```

- ##### props类型可以是：String、Number、Boolean、Array、Object、Date、Function、Symbol、自定义构造函数

- ##### 非prop的attribute：可以通过 $attrs 属性来访问这些attribute

- ##### 禁用attribute继承：可以在组件的选项中设置 inheritAttrs：false

- ##### 多个根节点的attribute继承：多个根节点的组件不具有自动attribute的行为，如果未显示绑定$attrs，将发出运行警告。



- ##### 自定义事件之事件名：与prop一样，当使用DOM模板时，应该使用kebal-case，如果是字符串模板，则没有这个限制

- ##### 验证抛出的事件：



- ##### v-model参数：

  ```html
  <my-component v-model:title="bookTitle"></my-component>
  
  app.component('my-component', {
    props: {
      title: String
    },
    emits: ['update:title'],
    template: `
      <input
        type="text"
        :value="title"
        @input="$emit('update:title', $event.target.value)">
    `
  })
  ```

- ##### 多个v-model的绑定：

- ##### 处理v-model修饰符：

  ```html
  当我们学习表单输入绑定时，我们看到 v-model 有内置修饰符——.trim、.number 和 .lazy。但是，在某些情况下，你可能还需要添加自己的自定义修饰符
  <my-component v-model.capitalize="myText"></my-component>
  
  app.component('my-component', {
    props: {
      modelValue: String,
      modelModifiers: {
        default: () => ({})
      }
    },
    emits: ['update:modelValue'],
    template: `
      <input type="text"
        :value="modelValue"
        @input="$emit('update:modelValue', $event.target.value)">
    `,
    created() {
      console.log(this.modelModifiers) // { capitalize: true }
    }
  })
  ```

- ##### 对于携带参数的v-model的绑定：生成的 prop 名称将为 `arg + "Modifiers"`

  ```html
  <my-component v-model:description.capitalize="myText"></my-component>
  
  app.component('my-component', {
    props: ['description', 'descriptionModifiers'],
    emits: ['update:description'],
    template: `
      <input type="text"
        :value="description"
        @input="$emit('update:description', $event.target.value)">
    `,
    created() {
      console.log(this.descriptionModifiers) // { capitalize: true }
    }
  })
  ```

- ##### 插槽之备用内容：<slot>备用内容</slot>

- ##### 插槽之具名插槽：

  ```html
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  // 组件内容
  <base-layout>
    <template v-slot:header>
      <h1>Here might be a page title</h1>
    </template>
  
    <template v-slot:default>
      <p>A paragraph for the main content.</p>
      <p>And another one.</p>
    </template>
  
    <template v-slot:footer>
      <p>Here's some contact info</p>
    </template>
  </base-layout>
  
  注意，v-slot 只能添加在 <template> 上 (只有一种例外情况)
  ```

- ##### 插槽之作用域插槽：

  ```html
  有时让插槽内容能够访问子组件中才有的数据是很有用的。当一个组件被用来渲染一个项目数组时，这是一个常见的情况，我们希望能够自定义每个项目的渲染方式
  <slot> 元素上的 attribute 被称为插槽 prop
    
   <ul>
    <li v-for="( item, index ) in items">
      <slot :item="item" :index="index" :another-attribute="anotherAttribute"></slot>
    </li>
  </ul>
  // ---------  
   <todo-list>
    <template v-slot:default="slotProps">
      <i class="fas fa-check"></i>
      <span class="green">{{ slotProps.item }}</span>
    </template>
  </todo-list>
  ```

- ##### 插槽之独占默认插槽的缩写语法：

  ```html
  <todo-list v-slot="slotProps">
    <i class="fas fa-check"></i>
    <span class="green">{{ slotProps.item }}</span>
  </todo-list>
  注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确
  只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法
  ```

- ##### 结构插槽prop：

  ```html
  <todo-list v-slot="{ item = 'Placeholder' }">
    // 为了避免冲突，也可以使用别名 { item : todoItem }
    <i class="fas fa-check"></i>
    <span class="green">{{ item }}</span>
  </todo-list>
  ```

- ##### 动态插槽名：

  ```html
  <base-layout>
    <template v-slot:[dynamicSlotName]>
      ...
    </template>
  </base-layout>
  ```

- ##### 具名插槽的缩写：跟 `v-on` 和 `v-bind` 一样，`v-slot` 也有缩写，即把参数之前的所有内容 (`v-slot:`) 替换为字符 `#`



- ##### provide和inject：

  ```js
  provide 一些组件的实例 property，这将是不起作用的，要访问组件实例 property，我们需要将 provide 转换为返回对象的函数
  app.component('todo-list', {
    data() {
      return {
        todos: ['Feed a cat', 'Buy tickets']
      }
    },
    provide() {
      return {
        todoLength: this.todos.length
      }
    },
    template: `
      ...
    `
  })
  ```

- ##### provide和inject的响应式：传递一个ref property对象或者reactive property给provide 或者使用computed组合API

- ##### 动态组件：通过keep-alive将动态组件包裹，失活的组件将会被缓存

- ##### 异步组件：vue提供了一个方法 defineAsyncComponent

  ```js
  const AsyncComp = defineAsyncComponent(
    () =>
      new Promise((resolve, reject) => {
        resolve({
          template: '<div>I am async!</div>'
        })
      })
  )
  
  结合webpack和es2015语法可以如下写法：
  const AsyncComp = defineAsyncComponent(() =>
    import('./components/AsyncComponent.vue')
  )
  ```

- ##### 与suspense一起使用：

- ##### 模板引用：$refs` 只会在组件渲染完成之后生效。这仅作为一个用于直接操作子元素的“逃生舱”——你应该避免在模板或计算属性中访问 `$refs

- ##### 边界情况处理：

  ```js
  // 1、强制更新：可以使用$forceUpdate
  // 2、低级静态组件与v-once
  ```



## 3、过渡 & 动画

- ##### 基于class的动画和过渡：

- ##### 过渡与style绑定：

- ##### 缓动效果：

- ##### 进入过渡 & 离开过渡：

  ```js
  // 1、单元素/组件过渡
  条件渲染 (使用 v-if)
  条件展示 (使用 v-show)
  动态组件
  组件根节点
  
  // 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理
  1、自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。
  2、如果过渡组件提供了 JavaScript 钩子函数 ，这些钩子函数将在恰当的时机被调用。
  3、如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此处指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)
  ```

- ##### 过渡class ：v-enter-form、v-enter-active、v-enter-to、v-leave-form、v-leave-active、v-leave-to

- ##### CSS过渡：

  ```css
  /* 可以为进入和离开动画设置不同的持续时间和动画函数 */
  .v-enter-active {
    transition: all 0.3s ease-out;
  }
  
  .v-leave-active {
    transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
  }
  
  .v-enter-from,
  .v-leave-to {
    transform: translateX(20px);
    opacity: 0;
  }
  ```

- ##### 自定义过渡class类名：

  ```js
  // 我们可以通过以下 attribute 来自定义过渡类名：
  enter-from-class
  enter-active-class
  enter-to-class
  leave-from-class
  leave-active-class
  leave-to-class
  // 它们的优先级高于普通的类名，当你希望将其它第三方 CSS 动画库与 Vue 的过渡系统相结合时十分有用
  ```

- ##### 同时使用过渡和动画：

- ##### 显性的过渡持续时间：transtion的duration属性，显式指定过渡持续时间

  ```html
  <transition :duration="{ enter: 500, leave: 800 }">...</transition>
  ```

- ##### JavaScript钩子：

  ```js
  <transition
    @before-enter="beforeEnter"
    @enter="enter"
    @after-enter="afterEnter"
    @enter-cancelled="enterCancelled"
    @before-leave="beforeLeave"
    @leave="leave"
    @after-leave="afterLeave"
    @leave-cancelled="leaveCancelled"
    :css="false"
  >
    <!-- ... -->
  </transition>
  
  // JS
  methods: {
    // --------
    // 进入时
    // --------
  
    beforeEnter(el) {
      // ...
    },
    // 当与 CSS 结合使用时
    // 回调函数 done 是可选的
    enter(el, done) {
      // ...
      done()
    },
    afterEnter(el) {
      // ...
    },
    enterCancelled(el) {
      // ...
    },
  
    // --------
    // 离开时
    // --------
  
    beforeLeave(el) {
      // ...
    },
    // 当与 CSS 结合使用时
    // 回调函数 done 是可选的
    leave(el, done) {
      // ...
      done()
    },
    afterLeave(el) {
      // ...
    },
    // leaveCancelled 只用于 v-show 中
    leaveCancelled(el) {
      // ...
    }
  }
  // 当只用 JavaScript 过渡的时候，在 enter 和 leave 钩子中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。添加 :css="false" 也会让 Vue 会跳过 CSS 的检测，除了性能略高之外，这也可以避免过渡过程中受到 CSS 规则的意外影响。
  ```

- ##### 初识渲染的过渡：通过添加appear属性，设置节点初始渲染的过渡

  ```html
  <transition appear>
    <!-- ... -->
  </transition>
  ```

- ##### 多个元素之间的过渡：

- ##### 过渡模式：in-out、out-in

- ##### 列表过渡：`<transition-group>` 组件，可以通过 `tag` attribute 指定渲染一个元素，内部元素**总是需要**提供唯一的 `key` attribute 值

- ##### 列表的移动过渡：添加 v-move类，与过渡class类似，也可以move-class attribute手动设置

  ```js
  // 其实 Vue 内部使用了一个叫 FLIP 的动画技术，它使用 transform 将元素从之前的位置平滑过渡到新的位置
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
  
  <div id="list-complete-demo" class="demo">
    <button @click="shuffle">Shuffle</button>
    <button @click="add">Add</button>
    <button @click="remove">Remove</button>
    <transition-group name="list-complete" tag="p">
      <span v-for="item in items" :key="item" class="list-complete-item">
        {{ item }}
      </span>
    </transition-group>
  </div>
  
  // JS
  const Demo = {
    data() {
      return {
        items: [1, 2, 3, 4, 5, 6, 7, 8, 9],
        nextNum: 10
      }
    },
    methods: {
      randomIndex() {
        return Math.floor(Math.random() * this.items.length)
      },
      add() {
        this.items.splice(this.randomIndex(), 0, this.nextNum++)
      },
      remove() {
        this.items.splice(this.randomIndex(), 1)
      },
      shuffle() {
        this.items = _.shuffle(this.items)
      }
    }
  }
  
  Vue.createApp(Demo).mount('#list-complete-demo')
  
  // css
  .list-complete-item {
    transition: all 0.8s ease;
    display: inline-block;
    margin-right: 10px;
  }
  
  .list-complete-enter-from,
  .list-complete-leave-to {
    opacity: 0;
    transform: translateY(30px);
  }
  
  .list-complete-leave-active {
    position: absolute;
  }
  ```

  

- ##### 其实 Vue 内部使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 的动画技术，它使用 transform 将元素从之前的位置平滑过渡到新的位置

- ##### 可复用的过渡：将 `<transition>` 或者 `<transition-group>` 作为根组件，然后将任何子组件放置其中就可以了

- ##### 动态过渡：

- ##### 关于状态过渡：

- ##### 状态动画与侦听器：



## 4、可复用 & 组合

- ##### 组合式API：

- ##### setup组件选项：`setup` 选项在组件被创建**之前**执行，一旦 `props` 被解析完成，它就将被作为组合式 API 的入口

- ##### watch响应式更改：接收三个参数 => 一个想要侦听的响应式引用或者getter函数、一个回调、可选的配置选项

- ##### 使用setup函数时，它接收两个参数 => props、context

  ```js
  export default {
    setup(props, context) {
      // Attribute (非响应式对象，等同于 $attrs)
      console.log(context.attrs)
  
      // 插槽 (非响应式对象，等同于 $slots)
      console.log(context.slots)
  
      // 触发事件 (方法，等同于 $emit)
      console.log(context.emit)
  
      // 暴露公共 property (函数)
      console.log(context.expose)
    }
  }
  ```

- ##### setup返回一个对象，在模板中使用时是被自动浅解包的

- ##### setup中使用生命周期钩子：

  ```js
  onBeforeMount、onMounted、onbeforeUpdate、onUpdated、onBeforeUnmounte、onUnmounted
  onErrorCaptured、onRenderTranted、onRenderTriggered
  onActivated、onDeactivated
  ```

- ##### 在setup中使用provide和inject：

  ```js
  // 显式的导入provide函数
  import { provide } from 'vue'
  setup() {
    provide(name<string>,value) // 两个参数
  }
  // 显式的导入inject
  import { inject } from 'vue'
  setup() {
    const foo = inject(name,defaultValue(默认值)) // 也是两个参数
  }
  ```

- ##### 添加响应性：在provide值时使用ref或者reactive

- ##### 当使用响应式 provide / inject 值时，建议尽可能将对响应式 property 的所有修改限制在定义 provide 的组件内部

- ##### 如果需要修改inject的数据，建议provide一个修改inject的方法

- ##### 为了确保provide的值不会被inject修改，建议使用readonly

- ##### 模板引用：模板引用只会在初始渲染之后获得赋值

- ##### 模板引用在v-for中的用法：

  ```html
  <div v-for="(item, i) in list" :ref="el => { if (el) divs[i] = el }">
      {{ item }}
    </div>
  ```

- ##### 侦听模板引用：

  ```js
  // 使用模板引用的侦听器应该用 flush: 'post' 选项来定义，这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素
  setup() {
        const root = ref(null)
        watchEffect(() => {
          console.log(root.value) // => <div>This is a root element</div>
        }, 
        {
          flush: 'post'
        })
        return {
          root
        }
      }
  ```

- ##### Mixin: 当组件和minxin对象含有同名选项时，这些选项将以恰当的方式进行合并

  ```js
  // 当数据发生冲突时，会以组件自身数据优先
  // 同名钩子函数将合并为一个数组，因此都将被调用。另外，mixin 对象的钩子将在组件自身钩子之前调用
  // 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对
  ```

- ##### 全局mixin ：app.mixin({})

- ##### 自定义选项合并策略：

  ```js
  // 自定义选项在合并时，默认策略为简单地覆盖已有值。如果想让某个自定义选项以自定义逻辑进行合并，可以在 app.config.optionMergeStrategies 中添加一个函数
  const app = Vue.createApp({})
  app.config.optionMergeStrategies.customOption = (toVal, fromVal) => {
    // return mergedVal
  }
  ```

- ##### 自定义指令：

  ```js
  const app = Vue.createApp({})
  // 注册一个全局自定义指令 `v-focus`
  app.directive('focus', {
    // 当被绑定的元素挂载到 DOM 中时……
    mounted(el) {
      // 聚焦元素
      el.focus()
    }
  })
  
  // 如果想注册局部指令，组件中也接受一个 directives 的选项
  directives: {
    focus: {
      // 指令的定义
      mounted(el) {
        el.focus()
      }
    }
  }
  ```

- ##### 自定义指令的钩子函数：

  ```js
  // created、beforeMounded、mounted、beforeUpdate、updated、beforeUnmounted、mounted
  // 参数：el、binding、vnode 和 prevVnode
  ```

- ##### 动态指令参数：

  ```js
  app.directive('pin', {
    mounted(el, binding) {
      el.style.position = 'fixed'
      // binding.value 是我们传递给指令的值——在这里是 200
      el.style.top = binding.value + 'px'
    }
  })
  
  // 动态指令参数
  <div id="dynamicexample">
    <h3>Scroll down inside this section ↓</h3>
    <p v-pin:[direction]="200">I am pinned onto the page at 200px to the left.</p>
  </div>
  // ----------
  app.directive('pin', {
    mounted(el, binding) {
      el.style.position = 'fixed'
      // binding.arg 是我们传递给指令的参数
      const s = binding.arg || 'top'
      el.style[s] = binding.value + 'px'
    }
  })
  
  // 函数简写：你可能想在 mounted 和 updated 时触发相同行为，而不关心其他的钩子函数
  app.directive('pin', (el, binding) => {
    el.style.position = 'fixed'
    const s = binding.arg || 'top'
    el.style[s] = binding.value + 'px'
  })
  
  ```

- ##### 自定义指令的对象字面量写法：

  ```js
  <div v-demo="{ color: 'white', text: 'hello!' }"></div>
  
  app.directive('demo', (el, binding) => {
    console.log(binding.value.color) // => "white"
    console.log(binding.value.text) // => "hello!"
  })
  ```

- ##### 在组件上使用：和[非 prop 的 attribute](https://v3.cn.vuejs.org/guide/component-attrs.html) 类似，当在组件中使用时，自定义指令总是会被应用在组件的根节点上

- ##### 和 attribute 不同，指令不会通过 `v-bind="$attrs"` 被传入另一个元素

- ##### teleport：

  ```vue
  app.component('modal-button', {
    template: `
      <button @click="modalOpen = true">
          Open full screen modal! (With teleport!)
      </button>
  
      <teleport to="body">
        <div v-if="modalOpen" class="modal">
          <div>
            I'm a teleported modal! 
            (My parent is "body")
            <button @click="modalOpen = false">
              Close
            </button>
          </div>
        </div>
      </teleport>
    `,
    data() {
      return { 
        modalOpen: false
      }
    }
  }
  ```

- ##### teleport与vue components一起使用：如果 `<teleport>` 包含 Vue 组件，则它仍将是 `<teleport>` 父组件的逻辑子组件

- ##### 同一个目标上使用多个teleport：

- ##### 渲染函数：render

  ```js
  const { createApp, h } = Vue
  
  const app = createApp({})
  
  app.component('anchored-heading', {
    render() {
      return h(
        'h' + this.level, // 标签名
        {}, // prop 或 attribute
        this.$slots.default() // 包含其子节点的数组
      )
    },
    props: {
      level: {
        type: Number,
        required: true
      }
    }
  })
  ```

- ##### DOM树：

- ##### 虚拟DOM树：

- ##### h()参数：

  ```js
  // @returns {VNode}
  h(
    // {String | Object | Function} tag
    // 一个 HTML 标签名、一个组件、一个异步组件、或
    // 一个函数式组件。
    //
    // 必需的。
    'div',
  
    // {Object} props
    // 与 attribute、prop 和事件相对应的对象。
    // 这会在模板中用到。
    //
    // 可选的。
    {},
  
    // {String | Array | Object} children
    // 子 VNodes, 使用 `h()` 构建,
    // 或使用字符串获取 "文本 VNode" 或者
    // 有插槽的对象。
    //
    // 可选的。
    [
      'Some text comes first.',
      h('h1', 'A headline'),
      h(MyComponent, {
        someProp: 'foobar'
      })
    ]
  )
  ```

- ##### 约束：VNodes 必须唯一

- ##### 创建组件 VNode：

  ```js
  // 要为某个组件创建一个 VNode，传递给 h 的第一个参数应该是组件本身
  render() {
    return h(ButtonCounter)
  }
  // 如果我们需要通过名称来解析一个组件，那么我们可以调用 resolveComponent
  const { h, resolveComponent } = Vue
  render() {
    const ButtonCounter = resolveComponent('ButtonCounter')
    return h(ButtonCounter)
  }
  ```

- ##### 函数式组件：

- ##### JSX：

- ##### 插件：

  ```js
  // 插件是自包含的代码，通常向 Vue 添加全局级功能。它可以是公开 install() 方法的 object，也可以是 function
  ```

- ##### 使用插件和编写插件：



## 5、高阶指南

- ##### 在vue中使用自定义元素：defineCustomElement

  ```js
  import { defineCustomElement } from 'vue'
  
  const MyVueElement = defineCustomElement({
    // 在此提供正常的 Vue 组件选项
    props: {},
    emits: {},
    template: `...`,
  
    // defineCustomElement 独有特性: CSS 会被注入到隐式根 (shadow root) 中
    styles: [`/* inlined css */`]
  })
  
  // 注册自定义元素
  // 注册完成后，此页面上的所有的 `<my-vue-element>` 标签会被更新
  customElements.define('my-vue-element', MyVueElement)
  
  // 你也可以编程式地实例化这个元素：
  // (只能在注册后完成此操作)
  document.body.appendChild(
    new MyVueElement({
      // initial props (optional)
    })
  )
  ```

- ##### 自定义元素的生命周期：

- ##### 文档：https://v3.cn.vuejs.org/guide/web-components.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0



- ##### 深入响应式原理：...



- ##### 响应式基础：

- ##### 响应式计算和侦听：computed、watch、watchEffect

- ##### 侦听响应式对象：使用侦听器来比较一个数组或对象的值，这些值是响应式的，要求它有一个由值构成的副本

- ##### watch和watchEffect共享停止侦听、清除副作用、副作用刷新时机、侦听器调试行为



- ##### 渲染机制和优化：

- ##### 异步更新队列：



## 6、工具

- ##### 单文件组件

  ```js
   // Vue SFC 是框架指定的文件格式，必须由 @vue/compiler-sfc 预编译为标准的 JavaScript 与 CSS。编译后的 SFC 是一个标准的 JavaScript（ES）模块
  ```

- ##### 为什么要使用SFC

- ##### Vue3的TypeScript支持

- ##### Vue CLI创建项目

- ##### 为globalProperties扩充类型：

  ```js
  // Vue 3 提供了一个 globalProperties 对象，用来添加可以被任意组件实例访问的全局 property
  import axios from 'axios'
  const app = Vue.createApp({})
  app.config.globalProperties.$http = axios
  // 验证数据的插件
  export default {
    install(app, options) {
      app.config.globalProperties.$validate = (data: object, rule: object) => {
        // 检查对象是否合规
      }
    }
  }
  ```

- ##### 注解返回类型:https://v3.cn.vuejs.org/guide/typescript-support.html#%E4%B8%BA-globalproperties-%E6%89%A9%E5%85%85%E7%B1%BB%E5%9E%8B



## 7、规模化

- ##### 路由

- ##### 状态管理

- ##### 服务端渲染

- ##### 安全



