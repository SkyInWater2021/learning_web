

# 项目搭建规范



## 一. 代码规范



### 1.1. 集成editorconfig配置

EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。

```yaml
# http://editorconfig.org

root = true

[*] # 表示所有文件适用
charset = utf-8 # 设置文件字符集为 utf-8
indent_style = space # 缩进风格（tab | space）
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型(lf | cr | crlf)
trim_trailing_whitespace = true # 去除行首的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off
trim_trailing_whitespace = false
```



VSCode需要安装一个插件：EditorConfig for VS Code

![image-20210722215138665](https://tva1.sinaimg.cn/large/008i3skNgy1gsq2gh989yj30pj05ggmb.jpg)



### 1.2. 使用prettier工具

Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。

1.安装prettier

```shell
npm install prettier -D
```

2.配置.prettierrc文件：

* useTabs：使用tab缩进还是空格缩进，选择false；
* tabWidth：tab是空格的情况下，是几个空格，选择2个；
* printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；
* singleQuote：使用单引号还是双引号，选择true，使用单引号；
* trailingComma：在多行输入的尾逗号是否添加，设置为 `none`；
* semi：语句末尾是否要加分号，默认值true，选择false表示不加；

```json
{
  "useTabs": false,
  "tabWidth": 2,
  "printWidth": 80,
  "singleQuote": true,
  "trailingComma": "none",
  "semi": false
}
```



3.创建.prettierignore忽略文件

```
/dist/*
.local
.output.js
/node_modules/**

**/*.svg
**/*.sh

/public/*
```



4.VSCode需要安装prettier的插件: 快捷键alt + shift + f，可以在VSCode中勾选Format On Save设置项，实现保存文件时自动格式化代码

![image-20210722214543454](https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg)

5.测试prettier是否生效

* 测试一：在代码中保存代码；
* 测试二：配置一次性修改的命令；

在package.json中配置一个scripts：执行npm run prettier 将所有代码进行一次格式化

```json
    "prettier": "prettier --write ."
```



### 1.3. 使用ESLint检测

1.在创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。

2.VSCode需要安装ESLint插件：

![image-20210722215933360](https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg)

3.解决eslint和prettier冲突的问题：

安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）

```shell
npm i eslint-plugin-prettier eslint-config-prettier -D
```

添加prettier插件：

```json
  "extends": [
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/typescript/recommended",
    "@vue/prettier",
    "@vue/prettier/@typescript-eslint",
    "plugin:prettier/recommended"
  ]
```



### 1.4. git Husky和eslint

虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：

* 也就是我们希望保证代码仓库中的代码都是符合eslint规范的；

* 那么我们需要在组员执行 `git commit ` 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；

那么如何做到这一点呢？可以通过Husky工具：

* husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push

如何使用husky呢？

这里我们可以使用自动配置命令：

```shell
npx husky-init && npm install
```

这里会做三件事：

1.安装husky相关的依赖：

![image-20210723112648927](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg)

2.在项目目录下创建 `.husky` 文件夹：

```
npx husky install
```



![image-20210723112719634](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg)

3.在package.json中添加一个脚本：

![image-20210723112817691](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg)

接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：

![image-20210723112932943](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg)





这个时候我们执行git commit的时候会自动对代码进行lint校验。



### 1.5. git commit规范

#### 1.5.1. 代码提交风格

通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg)

但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen

* Commitizen 是一个帮助我们编写规范 commit message 的工具；

1.安装Commitizen

```shell
npm install commitizen -D
```

2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：

```shell
npx commitizen init cz-conventional-changelog --save-dev --save-exact
```

这个命令会帮助我们安装cz-conventional-changelog：

![image-20210723145249096](https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg)

并且在package.json中进行配置：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg)

这个时候我们提交代码需要使用 `npx cz`：如果使用此命令不习惯，可以配置脚本 "commit": "npx cz"  ，执行npm run commit 提交代码

* 第一步是选择type，本次更新的类型

| Type     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| feat     | 新增特性 (feature)                                           |
| fix      | 修复 Bug(bug fix)                                            |
| docs     | 修改文档 (documentation)                                     |
| style    | 代码格式修改(white-space, formatting, missing semi colons, etc) |
| refactor | 代码重构(refactor)                                           |
| perf     | 改善性能(A code change that improves performance)            |
| test     | 测试(when adding missing tests)                              |
| build    | 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等） |
| ci       | 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 |
| chore    | 变更构建流程或辅助工具(比如更改测试环境)                     |
| revert   | 代码回退                                                     |

* 第二步选择本次修改的范围（作用域）

![image-20210723150147510](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg)

* 第三步选择提交的信息

![image-20210723150204780](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg)

* 第四步提交详细的描述信息

![image-20210723150223287](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg)

* 第五步是否是一次重大的更改

![image-20210723150322122](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg)

* 第六步是否影响某个open issue

![image-20210723150407822](https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg)

我们也可以在scripts中构建一个命令来执行 cz：

![image-20210723150526211](https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg)



#### 1.5.2. 代码提交验证

如果我们按照cz来规范了提交风格，但是依然有同事通过 `git commit` 按照不规范的格式提交应该怎么办呢？

* 我们可以通过commitlint来限制提交；

1.安装 @commitlint/config-conventional 和 @commitlint/cli

```shell
npm i @commitlint/config-conventional @commitlint/cli -D
```

2.在根目录创建commitlint.config.js文件，配置commitlint

```js
module.exports = {
  extends: ['@commitlint/config-conventional']
}
```

3.使用husky生成commit-msg文件，验证提交信息：

```shell
npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"
```



## 二. 三方库集成



#### 2.1、vue.config.js配置：

- **vue.config.js有三种配置方式：**

  ```shell
  // 方式一、直接通过CLI提供给我们的选项来配置：
  
  // 方式二、通过configureWebpack修改webpack的配置：可以是一个对象，直接合并；也可以是一个函数，接收一个config，通过修改config来修改配置
  
  // 方式三：通过chainWebpack修改webpack的配置：是一个函数，会接收一个基于webpack-chain的config对象，可以对配置进行修改
  
  const path = require('path')
  module.exports = {
    outputDir: './build',
    // ------方式一、  
     configureWebpack: {
       resolve: {
         alias: {
           views: '@/views'
         }
       }
     }
   // ------方式二、  
     configureWebpack: (config) => {
       config.resolve.alias = {
         '@': path.resolve(__dirname, 'src'),
         views: '@/views'
       }
     },
  // ------方式三、  
    chainWebpack: (config) => {
      config.resolve.alias.set('@', path.resolve(__dirname, 'src')).set('views', '@/views')
    }
  }
  
  ```

- ##### 关于webpack-chain：https://github.com/mozilla-neutrino/webpack-chain



#### 2.2、Vue-Router集成

- **安装最新版本：**

  ```shell
  npm install vue-router@next
  ```

  
  
- **配置路由信息**

  ```js
  import { createRouter, createWebHistory } from 'vue-router'
  
  const routes = [
    {
      path: '/',
      redirect: '/homeView'
    },
    {
      path: '/homeView',
      name: 'homeView',
      meta: {},
      component: () =>
        import(/* webpackChunkName: "homeView" */ '@/views/HomeView'),
      children: []
    },
    {
      path: '/:pathMatch(.*)*',
      name: 'notFound',
      component: () => import('@/views/error/NotFound')
    }
  ]
  
  const router = createRouter({
    history: createWebHistory(process.env.BASE_URL),
    routes
  })
  
  // ----- 路由守卫 -----
  router.beforeEach((to) => {
    console.log(to)
  })
  
  export default router
  ```

  

- **动态注册路由**

  ```js
  // utils
  let firstMenu = null
  
  /**
   *
   * @param  userMenus 角色菜单
   * @returns 角色菜单对应的路由对象
   */
  export function mapMenusToRoutes(userMenus) {
    const routes = []
    // 1. 获取所有的路由对象
    const allRoutes = []
    const routeFiles = require.context('@/router/userMenus', true, /\.js/)
    routeFiles.keys().forEach((key) => {
      const route = require('@/router/userMenus' + key.split('.')[1])
      allRoutes.push(route.default)
    })
  
    // 2. 根据角色菜单递归获取需要添加的路由对象
    const $_recurseGetRoute = (menus) => {
      for (const menu of menus) {
        if (!menu.children) {
          const route = allRoutes.find((route) => route.path === menu.path)
          if (route) {
            menu.component = route.component
            routes.push(menu)
            //获取到第一个路由对象
            if (!firstMenu) {
              firstMenu = menu
            }
          }
        } else {
          $_recurseGetRoute(menu.children)
        }
      }
    }
  
    $_recurseGetRoute(userMenus)
  
    return routes
  }
  
  export { firstMenu }
  ```

  

#### 2.3、Pinia的集成

- **安装**

  ```shell
  npm install pinia
  ```

- **store配置**

  ```js
  import { createPinia } from 'pinia'
  
  const store = createPinia({
    state: () => {
      return {}
    },
    getters: {},
    actions: {}
  })
  
  export default store
  
  ```

- **pinia文档: **https://pinia.vuejs.org/introduction.html



#### 2.4、Axios集成

- **安装**

  ```
  npm install axios
  ```

- **对axios的二次封装**

  - **类的封装**

    ```js
    import axios from 'axios'
    
    // ----- 封装一个request请求类 -----
    class HXRequest {
      instence = null // axios实例
      interceptor = null // 拦截操作对象
    
      constructor(config) {
        this.instence = axios.create(config)
        this.interceptor = config.interceptor
    
        // 1.如果创建实例时传入实例的拦截操作对象
        this.instence.interceptors.request.use(
          this.interceptor?.requestInterceptor,
          this.interceptor?.requestInterceptorCatch
        )
        this.instence.interceptor.response.use(
          this.interceptor?.responseInterceptor,
          this.interceptor?.responseInterceptorCatch
        )
    
        // 2.所有实例的拦截器
        this.instence.interceptor.request.use(
          (config) => {
            return config
          },
          (err) => {
            return err
          }
        )
        this.instence.interceptors.response.use(
          (res) => {
            return res
          },
          (err) => {
            return err
          }
        )
      }
    
      request(config) {
        return new Promise((resolve, reject) => {
          // 3.1 某次请求需要执行请求成功的拦截处理
          if (config.interceptor?.requestInterceptor) {
            config = config.interceport.requestInterceptor(config)
          }
          this.instence
            .request(config)
            .then((res) => {
              // 3.2 某次请求需要执行响应成功的拦截处理
              if (config.interceport.responseInterceptor) {
                res = config.interceport.responseInterceptor(res)
              }
              resolve(res.data)
            })
            .catch((err) => {
              reject(err)
            })
        })
      }
    
      get(config) {
        return this.request({ ...config, method: 'GET' })
      }
      post(config) {
        return this.request({ ...config, method: 'POST' })
      }
      delete(config) {
        return this.request({ ...config, method: 'DELETE' })
      }
      patch(config) {
        return this.request({ ...config, method: 'PATCH' })
      }
      put(config) {
        return this.request({ ...config, method: 'PUT' })
      }
    }
    
    export default HXRequest
    
    ```

  - **config配置**

    ```js
    const TIME_OUT = 10000
    let BASE_URL = ''
    let BASE_HEADER = {
      'Content-Type': 'application/json'
    }
    
    if (process.env.NODE_ENV === 'development') {
      BASE_URL = '/'
    } else if (process.env.NODE_ENV === 'production') {
      BASE_URL = '/'
    } else if (process.env.NODE_ENV === 'test') {
      BASE_URL = '/'
    }
    
    export { BASE_URL, TIME_OUT, BASE_HEADER }
    ```

  - **创建请求实例**

    ```js
    import HXRequest from './request/request'
    import { BASE_URL, BASE_HEADER, TIME_OUT } from './request/config'
    
    import localCache from '@/utils/localCache'
    
    // ----- 创建第一个请求实例 requestInstence -----
    
    // 1.关于interceptor参数的介绍
    // interceptor: {
    //   requestInterceptor: (config) => {} // 请求成功的拦截
    //   requestInterceptorCatch: (err) => {} // 请求失败的拦截
    //   responseInterceptor: (res) => {} // 响应成功的拦截
    //   responseInterceptorCatch: (err) => {} // 响应失败的拦截
    // }
    const requestInstence = new HXRequest({
      baseUrl: BASE_URL,
      timeout: TIME_OUT,
      headers: BASE_HEADER,
      interceptor: {
        requestInterceptor: (config) => {
          // 2.发送请求时携带token
          const token = localCache.getToken()
          if (token) {
            config.headers.Authorization = `Bearer ${token}`
          }
          return config
        },
        requestInterceptorCatch: (err) => {
          return err
        },
        responseInterceptor: (res) => {
          return res
        },
        responseInterceptorCatch: (err) => {
          return err
        }
      }
    })
    
    export { requestInstence }
    
    // ----- 创建第二个请求实例 xxxxx -----
    ```



#### 2.5、Element Plus 集成

- **安装**

  ```shell
  // 1.安装 Element Plus
  npm install element-plus --save
  // 2.安装自动导入插件
  npm install -D unplugin-vue-components unplugin-auto-import
  ```
  
- **webpack配置**

  ```js
  const AutoImport = require('unplugin-auto-import/webpack')
  const Components = require('unplugin-vue-components/webpack')
  const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')
  
  module.export = {
  // ....
  	configureWebpack: {
  		plugins: [
        AutoImport({
          imports: ['vue'],
          resolvers: [
            ElementPlusResolver({
              importStyle: 'css',
              exclude: new RegExp(/^(?!.*loading-directive).*$/)
            })
          ]
        }),
        Components({
          resolvers: [
            ElementPlusResolver({
              importStyle: 'css'
            })
          ]
        })
      ]
  	}
  }
  
  
  // 注意,对于某些以service方式调用的需要单独导入样式，例如：
  import { ElMessage, ElMessageBox } from 'element-plus'
  import 'element-plus/es/components/message-box/style/css'
  import 'element-plus/es/components/message/style/css'
  ```
  
- **组件注册方法**

  ```js
  // src下新建 global文件夹，管理一些全局注册的方法,并新建一个index.js作为global的统一出口
  
  // 1.global/registerElement.js
  import { ElButton, ElRow, ElCol, ElIcon } from 'element-plus'
  
  const components = [ElButton, ElRow, ElCol, ElIcon]
  
  const registerElement = (app) => {
    for (const component of components) {
      app.component(component.name, component)
    }
  }
  
  export default registerElement
  
  // 2.global/index.js
  import registerElement from './registerElement'
  
  const globalRegister = (app) => {
    registerElement(app)
  }
  
  export default globalRegister
  
  // 3. main.js
  import globalRegister from './global'
  globalRegister(app) //全局注册
  
  ```




#### 2.6、样式初始化

- **安装**

  ```shell
  npm install normalize.css
  ```

- **导入**

  ```shell
  // main.js
  import 'normalize.css'
  ```

  

#### 2.7、echarts集成

- **安装**

  ```shell
  npm install echarts
  ```

- **echarts二次封装**

  ```js
  // 1.基础容器封装
  <template>
    <div class="base-echart">
      <div ref="echartDivRef" :style="{ width: width, height: height }"></div>
    </div>
  </template>
  
  <script setup>
  import { ref, onMounted, watchEffect } from 'vue'
  import useEchart from '../hooks/useEchart'
  
  const props = defineProps({
    width: {
      type: String,
      default: '100%'
    },
    height: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      required: true
    }
  })
  
  const echartDivRef = ref()
  
  onMounted(() => {
    const { setOptions } = useEchart(echartDivRef.value)
  
    watchEffect(() => {
      setOptions(props.options)
    })
  })
  </script>
  
  <style scoped></style>
  
  
  // 2.饼图、折线图、柱状图、...
  ....
  
  ```



#### 2.8、SVG组件库集成

- **创建svgIcon文件夹**

- **在svgIcon文件夹下创建 svg文件夹存放 `.svg` 文件**

- **在svgIcon文件夹下创建文件 index.js**

  ```js
  // index.js 目的是将所有.svg文件按照模块引入
  const req = require.context('./svg', false, /\.svg$/)
  const requireAll = (requireContext) => requireContext.keys().map(requireContext)
  requireAll(req)
  ```

- **在svgIcon文件夹下创建文件 SvgTemplate.vue**

  ```js
  <template>
    <div>
      <svg :class="svgClass" aria-hidden="true">
        <use :xlink:href="iconName" />
      </svg>
    </div>
  </template>
  <script setup>
  import { defineProps, computed } from 'vue'
  // name: 'svgIcon',
  const props = defineProps({
    iconClass: {
      type: String,
      required: true
    },
    className: {
      type: String,
      default: ''
    }
  })
  const iconName = computed(() => {
    return `#icon-${props.iconClass}`
  })
  const svgClass = computed(() => {
    if (props.className) {
      return 'svg-icon' + props.className
    } else {
      return 'svg-icon'
    }
  })
  </script>
  <style scoped>
  .svg-icon {
    padding-right: 1em;
    width: 1em;
    height: 1em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
  }
  </style>
  ```

- **对 svg 组件库进行注册**  (与Element Plus注册思路相同)

  ```js
  // 在scr下的global文件夹下新建registerSvg.js 和 index.js
  // 1.resgiterSvg.js
  import '@/components/svgIcon/index.js'
  import SvgIcon from '@/components/svgIcon/SvgTemplate' // svg组件
  
  const registerSvg = function (app) {
    app.component('svg-icon', SvgIcon)
  }
  
  export default registerSvg
  
  // 2.index.js
  import registerSvg from './registerSvg'
  const globalRegister = (app) => {
    registerSvg(app)
  }
  export default globalRegister
  
  ```

- **配置Loader（重点）**

  - **安装 Loader**

    ```shell
    npm install svg-sprite-loader -D
    ```

  - **webpack配置**

    ```js
    // vue.config.js
    
    const path = require('path')
    const resolve = (dir) => {
      return path.join(__dirname, '.', dir)
    }
    
    chainWebpack: (config) => {
        // ----- 配置SVG Loader -----
        config.module.rules.delete('svg') //重点:删除默认配置中处理svg,
        config.module
          .rule('svg-sprite-loader')
          .test(/\.svg$/)
          .include.add(resolve('src/components/svgIcon/svg')) //处理svg目录
          .end()
          .use('svg-sprite-loader')
          .loader('svg-sprite-loader')
          .options({
            symbolId: 'icon-[name]'
          })
      }
    ```

    

- **在项目中使用**

  ```js
  // svg组件名: xxx.svg 中的xxx
  <svg-icon :icon-class="svg组件名" />
  ```
  
  

#### 2.9、Element Plus Icons集成

- **安装**

  ```shell
   npm install @element-plus/icons-vue
  ```

- **按需引入**

  ```js
  // 和 Element Plus 按需引入一致,可参考 2.5
  // src/global/registerElementIcons.js
  import { Refresh, Search } from '@element-plus/icons-vue'
  const icons = [Refresh, Search]
  const registerIcons = function (app) {
    for (const icon of Object.values(icons)) {
      app.component(icon.name, icon)
    }
  }
  export default registerIcons
  
  // global/index.js
  import registerElement from './registerElement'
  import registerElementIcons from './registerElementIcons'
  
  import registerSvg from './registerSvg'
  
  const globalRegister = (app) => {
    registerElementIcons(app)
  }
  export default globalRegister
  
  ```

- **页面使用**：https://element-plus.gitee.io/zh-CN/component/icon.html

  
