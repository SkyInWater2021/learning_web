# 基本实现（2022-4-18）



## 1、代码规范

#### ~ 集成editConfig配置

```shell
# http://editorconfig.org
root = true
[*] # 表示所有文件适用
charset = utf-8 # 设置文件字符集为 utf-8
indent_style = space # 缩进风格（tab | space）
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型(lf | cr | crlf)
trim_trailing_whitespace = true # 去除行首的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off
trim_trailing_whitespace = false
```

- ##### VSCode需要安装一个插件：EditorConfig for VS Code



#### ~使用prettier工具

- ##### Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。

- ##### 安装：npm install prettier -D

- ##### 创建并配置.prettier文件：

  ```shell
  {
    "useTabs": false,
    "tabWidth": 2,
    "printWidth": 80,
    "singleQuote": true,
    "trailingComma": "none",
    "semi": false
  }
  ```

- ##### 创建并配置.prettierignore忽略文件

  ```
  /dist/*
  .local
  .output.js
  /node_modules/**
  
  **/*.svg
  **/*.sh
  
  /public/*
  ```

- ##### VSCode需要安装插件：Prettier - Code  formatter

- ##### 在package.json中配置一个scripts：

  ```shell
   "prettier": "prettier --write ."
   //执行 npm run prettier 可以全局执行一次prettier格式化
  ```



#### ~使用ESLint检测

- ##### VSCode需要安装ESLint插件：ESLint

- ##### 解决ESLint与prettier冲突的问题：

  ```shell
  // 安装插件：
  npm i eslint-plugin-prettier eslint-config-prettier -D
  // 添加prettier插件,在.eslintrc.js中添加:
    extends: [
      "plugin:vue/vue3-essential",
      "eslint:recommended",
      "@vue/typescript/recommended",
      "@vue/prettier",
      "@vue/prettier/@typescript-eslint",
      'plugin:prettier/recommended'
    ],
    
    
  // vue3开发中.eslint.rc配置信息：
  module.exports = {
    root: true,
    env: {
      node: true,
      'vue/setup-compiler-macros': true
    },
    globals: {
      AMap: 'true'
    },
    extends: [
      'plugin:vue/vue3-essential',
      'eslint:recommended',
      '@vue/prettier',
      '@vue/prettier/@typescript-eslint',
      'plugin:prettier/recommended'
    ],
    parserOptions: {
      ecmaVersion: 2020,
      parser: 'babel-eslint'
    },
    rules: {
      'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
      'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
      'no-unused-vars': 'off',
      'vue/valid-define-emits': 'off'
    }
  }
  ```



#### ~使用git Husky和eslint：

- ##### 保证代码仓库中的代码都是符合eslint规范的，执行 git commit ` 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复

- ##### husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push

- ##### 自动配置命令：

  ```shell
  npx husky-init && npm install
  
  // 该命令会执行三件事：安装husky相关依赖、在项目目录下创建.husky文件夹、在package.json中添加一个脚本prepare
  ```

- ##### 在进行commit时，执行lint脚本： 在pre-commit文件下添加 npm run lint 脚本



#### ~gitcommit规范

- ##### 代码提交风格：通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。

- ##### 使用Commitizen工具：

  ```shell
  // 安装Commitizen：
  npm install commitizen -D
  
  
  // 安装cz-conventional-changelog，并且初始化cz-conventional-changelog：
  npx commitizen init cz-conventional-changelog --save-dev --save-exact
  
  // 上述命令会帮助我们安装cz-conventional-changelog，并且在package.json中进行配置：
  "config": {
      "commitizen": {
        "path": "./node_modules/cz-conventional-changelog"
      }
    }
    
   // 这个时候我们提交代码需要使用 `npx cz`
  ```

- ##### 提交代码： npx cz，我们也可以在scripts中构建一个命令来执行 cz =>  “commit”:"cz"   => npm run commit提交

  ```shell
  // 1、选择本次更新类型
  | Type     | 作用                                                         |
  | -------- | ------------------------------------------------------------ |
  | feat     | 新增特性 (feature)                                           |
  | fix      | 修复 Bug(bug fix)                                            |
  | docs     | 修改文档 (documentation)                                     |
  | style    | 代码格式修改(white-space, formatting, missing semi colons, etc) |
  | refactor | 代码重构(refactor)                                           |
  | perf     | 改善性能(A code change that improves performance)            |
  | test     | 测试(when adding missing tests)                              |
  | build    | 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等） |
  | ci       | 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 |
  | chore    | 变更构建流程或辅助工具(比如更改测试环境)                     |
  | revert   | 代码回退                                                     |
  
  // 2、选择本次修改的范围（作用域）
  
  // 3、简写本次提交信息
  
  // 4、填写本次提交详细信息
  
  // 5、本次修改是否是一次重大修改
  
  // 6、是否影响到某个 open issue
  ```



#### ~提交代码验证

- ##### 如果我们按照cz来规范了提交风格，但是依然有同事通过 `git commit` 按照不规范的格式提交应该怎么办呢？

- ##### 我们可以通过commitlint来限制提交；

  ```shell
  // 1、安装 @commitlint/config-conventional 和 @commitlint/cli
  npm i @commitlint/config-conventional @commitlint/cli -D
  
  // 2、在根目录创建commitlint.config.js文件，配置commitlint
  module.exports = {
    extends: ['@commitlint/config-conventional']
  }
  
  // 3、使用husky生成commit-msg文件，验证提交信息
  npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"
  ```

  

## 2、第三方库集成

#### ~vue.config.js配置：

- ##### vue.config.js有三种配置方式：

  ```shell
  // 方式一、直接通过CLI提供给我们的选项来配置：
  
  // 方式二、通过configureWebpack修改webpack的配置：可以是一个对象，直接合并；也可以是一个函数，接收一个config，通过修改config来修改配置
  
  // 方式三：通过chainWebpack修改webpack的配置：是一个函数，会接收一个基于webpack-chain的config对象，可以对配置进行修改
  
  const path = require('path')
  module.exports = {
    outputDir: './build',
    // ------方式一、  
     configureWebpack: {
       resolve: {
         alias: {
           views: '@/views'
         }
       }
     }
   // ------方式二、  
     configureWebpack: (config) => {
       config.resolve.alias = {
         '@': path.resolve(__dirname, 'src'),
         views: '@/views'
       }
     },
  // ------方式三、  
    chainWebpack: (config) => {
      config.resolve.alias.set('@', path.resolve(__dirname, 'src')).set('views', '@/views')
    }
  }
  
  ```

- ##### 关于webpack-chain：https://github.com/mozilla-neutrino/webpack-chain



#### ~vue-router和vuex集成：

- ##### 安装最新版本：

  ```js
  npm install vue-router@next
  npm install vuex@next
  
  // 创建router对象：
  import { createRouter, createWebHashHistory } from 'vue-router'
  const route = [
  	{
  		path: '/',
  		redirect: '/main'
  	},
  	{
  		path: '/main',
  		name: 'main'
  		component: () => import('@/views/main/main.vue')
  	},
  	{
  		path:'/:pathMatch(.*)*',
  		name: 'notFound',
  		component: () => important('@/views/error/notFound.vue')
  	}
  ]
  
  const router = {
  route,
  history: createWebHashHistory()
  }
  
  // 创建vuex对象
  import { createStore } from 'vuex'
  const store = createStore({
    state() {
      return {}
    },
    getters:{},
    mutations:{},
    actions:{},
    modules:{}
  })
  
  
  // 安装store和router
  import { createApp } from 'vue'
  import APP from './App'
  createApp(App).use(router).use(store).mount(#app)
  ```



#### ~axios集成：

- ##### 安装：npm install axios

- ##### 对axios封装：

  ```js
  // services -> index.js 、request -> config.js、request.js
  
  //  config.js 请求相关的配置
  const TIME_OUT = 5000
  let BASE_URL = ''
  let BASE_Header = {
    'Content-Type': 'application/json'
  }
  if (process.env.NODE_ENV === 'development') {
    // BASE_URL = '/api'
    BASE_URL = ''
  } else if (process.env.NODE_ENV === 'production') {
    BASE_URL = './'
  } else if (process.env.NODE_ENV === 'test') {
    BASE_URL = './'
  }
  
  export { BASE_URL, TIME_OUT, BASE_Header }
  
  
  // request.js 对axios进行封装
  class HYRequest {
    instence = null,
    interceptor = null
    
    constructor(config) {
      this.instence = axios.create(config)
      this.interceptor = config.interceptor
      // 特定实例的拦截器
      this.instence.interceptors.request.use(
        this.interceptor?.requestInterceptor,
        this.interceptor?.requestInterceptorCatch
      )
      this.instence.interceptors.response.use(
        this.interceptor?.responseInterceptor,
        this.interceptor?.responseInterceptorCatch
      )
      
      // 所有实例的拦截器
      this.instence.interceptors.request.use(
        (config) => {
          return config
        },
        (err) => {
          return err
        }
      )
      this.instence.interceptors.response.use(
        (res) => {
          return res
        },
        (err) => {
          return err
        }
      )
    }
    
     request(config) {
      return new Promise((resolve, reject) => {
        // 1.1 发送请求时执行此请求的请求拦截
        if (config.interceport?.requestInterceptor) {
          config = config.interceport.requestInterceptor(config)
        }
  
        this.instence
          .request(config)
          .then((res) => {
            // 1.2 发送请求时执行此请求的响应拦截
            if (config.interceport?.responseInterceptor) {
              res = config.interceport.responseInterceptor(res)
            }
            resolve(res.data)
          })
          .catch((err) => {
            reject(err)
          })
      })
    }
  
    get(config) {
      return this.request({ ...config, method: 'GET' })
    }
    post(config) {
      return this.request({ ...config, method: 'POST' })
    }
    delete(config) {
      return this.request({ ...config, method: 'DELETE' })
    }
    patch(config) {
      return this.request({ ...config, method: 'PATCH' })
    }
    put(config) {
      return this.request({ ...config, method: 'PUT' })
    }
  }
  
  
  // index.js 创建请求的实例对象
  import HYRequest from './request/request'
  import { BASE_URL, TIME_OUT, BASE_Header } from './request/config'
  
  import localCache from '@/utils/cache'
  
  const requestInstence = new HYRequest({
    baseURL: BASE_URL,
    timeout: TIME_OUT,
    headers: BASE_Header,
    interceptor: {
      requestInterceptor: (config) => {
        const token = localCache.getToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      requestInterceptorCatch: (err) => {
        return err
      },
      responseInterceptor: (res) => {
        return res
      },
      responseInterceptorCatch: (error) => {
        return error
      }
    }
  })
  
  export default requestInstence
  
  

#### ~element-plus集成：

- ##### 	见vue3文件夹下element自动导入



#### ~echarts集成：

- ##### 安装：npm install ecahrts

- ##### 编写使用echarts的hooks：

  ```js
  import * as echarts from 'echarts'
  
  export default function (el) {
    const echartInstance = echarts.init(el)
  
    const setOptions = (options) => {
      echartInstance.setOption(options)
    }
  
    const updateSize = () => {
      echartInstance.resize()
    }
  
    window.addEventListener('resize', () => {
      echartInstance.resize()
    })
  
    return {
      echartInstance,
      setOptions,
      updateSize
    }
  }
  ```

- ##### echarts基本封装：

  ```vue
  <template>
    <div class="base-echart">
      <div ref="echartDivRef" :style="{ width: width, height: height }"></div>
    </div>
  </template>
  
  <script setup>
  import { ref, onMounted, watchEffect } from 'vue'
  import useEchart from '../hooks/useEchart'
  
  const props = defineProps({
    width: {
      type: String,
      default: '100%'
    },
    height: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      required: true
    }
  })
  
  const echartDivRef = ref()
  
  onMounted(() => {
    const { setOptions } = useEchart(echartDivRef.value)
  
    watchEffect(() => {
      setOptions(props.options)
    })
  })
  </script>
  
  <style scoped></style>
  
  ```



#### ~样式初始化：

- ##### 安装：npm install normalize.css

  ```js
  // 在main.js中引入
  import 'normalize.css'
  ```



#### ~element-plus二次封装：

- 



#### ~编写utils工具函数：

- 



#### ~



